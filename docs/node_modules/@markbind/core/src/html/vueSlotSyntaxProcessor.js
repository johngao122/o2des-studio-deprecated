"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renameSlot = exports.transformOldSlotSyntax = exports.shiftSlotNodeDeeper = exports.getVslotShorthandName = void 0;
const cheerio_1 = __importDefault(require("cheerio"));
const has_1 = __importDefault(require("lodash/has"));
const find_1 = __importDefault(require("lodash/find"));
const _ = {
    has: has_1.default,
    find: find_1.default,
};
function getVslotShorthandName(node) {
    if (!node.attribs) {
        return '';
    }
    const keys = Object.keys(node.attribs);
    const vslotShorthand = _.find(keys, key => key.startsWith('#'));
    if (!vslotShorthand) {
        return '';
    }
    return vslotShorthand.substring(1, vslotShorthand.length); // remove #
}
exports.getVslotShorthandName = getVslotShorthandName;
/*
 * Shifts the slot node deeper by one level by creating a new intermediary node with template tag name.
 */
function shiftSlotNodeDeeper(node) {
    var _a;
    const nodeChildren = (_a = node.children) !== null && _a !== void 0 ? _a : [];
    nodeChildren.forEach((child) => {
        var _a, _b;
        const vslotShorthandName = getVslotShorthandName(child);
        if (vslotShorthandName && child.name !== 'template') {
            const newSlotNode = cheerio_1.default.parseHTML('<template></template>')[0];
            const vslotShorthand = `#${vslotShorthandName}`;
            newSlotNode.attribs = (_a = newSlotNode === null || newSlotNode === void 0 ? void 0 : newSlotNode.attribs) !== null && _a !== void 0 ? _a : {};
            newSlotNode.attribs[vslotShorthand] = '';
            if (child.attribs) {
                delete child.attribs[vslotShorthand];
            }
            newSlotNode.parent = node;
            child.parent = newSlotNode;
            newSlotNode.children = (_b = newSlotNode === null || newSlotNode === void 0 ? void 0 : newSlotNode.children) !== null && _b !== void 0 ? _b : [];
            newSlotNode.children.push(child);
            // replace the shifted old child node with the new slot node
            nodeChildren.forEach((childNode, idx) => {
                if (childNode === child) {
                    nodeChildren[idx] = newSlotNode;
                }
            });
        }
    });
    node.children = nodeChildren;
}
exports.shiftSlotNodeDeeper = shiftSlotNodeDeeper;
/*
 * Transforms deprecated vue slot syntax (slot="test") into the updated Vue slot shorthand syntax (#test).
 */
function transformOldSlotSyntax(node) {
    if (!node.children) {
        return;
    }
    node.children.forEach((child) => {
        if (child.attribs && _.has(child.attribs, 'slot')) {
            const vslotShorthandName = `#${child.attribs.slot}`;
            child.attribs[vslotShorthandName] = '';
            delete child.attribs.slot;
        }
    });
}
exports.transformOldSlotSyntax = transformOldSlotSyntax;
function renameSlot(node, originalName, newName) {
    if (!node.children) {
        return;
    }
    node.children.forEach((child) => {
        const vslotShorthandName = getVslotShorthandName(child);
        if (vslotShorthandName && vslotShorthandName === originalName) {
            const newVslot = `#${newName}`;
            if (child.attribs) {
                child.attribs[newVslot] = '';
                delete child.attribs[`#${vslotShorthandName}`];
            }
        }
    });
}
exports.renameSlot = renameSlot;
//# sourceMappingURL=vueSlotSyntaxProcessor.js.map